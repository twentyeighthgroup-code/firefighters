<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>üî• –ü–û–ñ–ê–†–ù–´–ô: –õ–ï–ì–ï–ù–î–ê 2.0 - –£–õ–£–ß–®–ï–ù–ù–ê–Ø –ì–†–ê–§–ò–ö–ê</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rubik+Burned&display=swap');
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #000;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      overflow: hidden;
      height: 100vh;
      touch-action: manipulation;
    }
    #container {
      position: relative;
      width: 100vw;
      height: 100vh;
    }
    #canvas {
      display: block;
      background: radial-gradient(circle at top, #1a0033, #000011);
      cursor: pointer;
    }
    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      right: 20px;
      display: flex;
      justify-content: space-between;
      z-index: 100;
      pointer-events: none;
    }
    .hud-item {
      background: rgba(255, 50, 50, 0.9);
      padding: 12px 20px;
      border-radius: 30px;
      font-weight: 700;
      box-shadow: 0 0 20px #ff0000;
      backdrop-filter: blur(10px);
    }
    #rank {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 28px;
      color: gold;
      text-shadow: 0 0 30px gold;
      font-weight: 900;
    }
    #team {
      position: absolute;
      bottom: 100px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 10px;
      pointer-events: all;
      z-index: 101;
    }
    .hero-btn {
      width: 70px;
      height: 90px;
      border: 3px solid #ffaa00;
      border-radius: 15px;
      background: #333 url('data:image/svg+xml;base64,...') center/contain; /* Placeholder */
      cursor: pointer;
      transition: all 0.3s;
      box-shadow: 0 0 15px #ff6600;
    }
    .hero-btn.active {
      border-color: lime;
      box-shadow: 0 0 30px lime;
      transform: scale(1.1);
    }
    .hero-btn:active { transform: scale(0.95); }
    #menu, #shop {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.98);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 200;
      backdrop-filter: blur(20px);
    }
    h1 {
      font-family: 'Rubik Burned', cursive;
      font-size: 5vw;
      color: #ff4400;
      text-shadow: 0 0 40px #ff0000;
      margin-bottom: 40px;
    }
    .btn {
      margin: 15px;
      padding: 20px 50px;
      background: linear-gradient(45deg, #ff4444, #ff8800);
      border: none;
      border-radius: 50px;
      color: white;
      font-size: 24px;
      font-weight: 700;
      box-shadow: 0 10px 30px rgba(255,68,0,0.6);
      cursor: pointer;
      transition: all 0.3s;
    }
    .btn:hover { transform: translateY(-5px); box-shadow: 0 15px 40px rgba(255,68,0,0.8); }
    .btn:active { transform: scale(0.98); }
    #boss-hp {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 400px;
      height: 40px;
      background: #333;
      border: 4px solid #ff0000;
      border-radius: 20px;
      overflow: hidden;
      display: none;
    }
    #boss-hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffff00);
      width: 100%;
      transition: width 0.5s;
      box-shadow: 0 0 20px #ff0000;
    }
  </style>
</head>
<body>
  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="hud">
      <div class="hud-item">–£—Ä. <span id="level">1</span></div>
      <div class="hud-item">–°–ø–∞—Å–µ–Ω–æ <span id="saved">0</span></div>
      <div class="hud-item">–ñ–∏–∑–Ω–∏ ‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
      <div class="hud-item">–ö–æ–º–±–æ √ó<span id="combo">1</span></div>
      <div class="hud-item">üí∞ <span id="money">0</span></div>
    </div>
    <div id="rank">–ù–û–í–ò–ß–û–ö</div>
    <div id="boss-hp"><div id="boss-hp-fill"></div></div>
    <div id="team">
      <div class="hero-btn active" data-hero="0"></div>
      <div class="hero-btn" data-hero="1"></div>
      <div class="hero-btn" data-hero="2"></div>
      <div class="hero-btn" data-hero="3"></div>
    </div>

    <!-- Overlay Menus -->
    <div id="menu">
      <h1>üî• –ü–û–ñ–ê–†–ù–´–ô –õ–ï–ì–ï–ù–î–ê</h1>
      <button class="btn" onclick="startGame()">üöÄ –ù–ê–ß–ê–¢–¨ –ú–ò–°–°–ò–Æ</button>
      <button class="btn" onclick="openShop()">üõí –ú–ê–ì–ê–ó–ò–ù</button>
    </div>
    <div id="shop">
      <h1>üõí –£–õ–£–ß–®–ï–ù–ò–Ø</h1>
      <button class="btn" onclick="buyUpgrade('hose')">–®–ª–∞–Ω–≥ +50% ‚Äî 500üí∞</button>
      <button class="btn" onclick="buyUpgrade('ladder')">–õ–µ—Å—Ç–Ω–∏—Ü–∞ √ó2 ‚Äî 2000üí∞</button>
      <button class="btn" onclick="buyUpgrade('auto')">–ê–≤—Ç–æ-—Å–ø–∞—Å ‚Äî 10000üí∞</button>
      <button class="btn" onclick="buyUpgrade('life')">‚ù§Ô∏è –ñ–∏–∑–Ω—å ‚Äî 5000üí∞</button>
      <button class="btn" onclick="closeShop()">üîô –ù–ê–ó–ê–î</button>
    </div>
  </div>

  <script>
    Telegram.WebApp.ready();
    Telegram.WebApp.expand();

    // Game State
    let gameState = {
      level: 1, money: 0, saved: 0, lives: 3, combo: 1, comboTime: 0,
      activeHero: 0, upgrades: {hose:1, ladder:1, auto: false, lives:0},
      bossActive: false, bossHP: 100,
      particles: [], buildings: [], rain: [], shake: 0,
      gameActive: false, weather: 'clear'
    };

    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    let cw, ch;

    function resize() {
      cw = canvas.width = window.innerWidth;
      ch = canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);
    resize();

    // Particle Class for Fire, Smoke, Sparks, Rain
    class Particle {
      constructor(x, y, type, vx = 0, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx + (Math.random() - 0.5) * 2;
        this.vy = vy + (Math.random() - 0.5) * 2;
        this.life = 1;
        this.decay = 0.02 + Math.random() * 0.01;
        this.size = 2 + Math.random() * 4;
        this.type = type; // 'fire', 'smoke', 'spark', 'rain'
        this.color = type === 'fire' ? `hsl(${30 + Math.random()*30}, 100%, ${50 + Math.random()*30}%)` :
                      type === 'smoke' ? `rgba(100,100,100,${0.5 + Math.random()*0.5})` :
                      type === 'spark' ? '#ffff00' : '#00aaff';
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        this.vy += 0.1; // gravity
        this.vx *= 0.98;
        this.life -= this.decay;
        if (this.type === 'fire') this.size += 0.1;
      }
      draw() {
        ctx.save();
        ctx.globalAlpha = this.life;
        ctx.shadowColor = this.color;
        ctx.shadowBlur = 10 + this.life * 20;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // Building Class
    class Building {
      constructor() {
        this.x = Math.random() * (cw - 200) + 100;
        this.y = ch - 300;
        this.width = 150 + Math.random() * 80;
        this.height = 250 + Math.random() * 100;
        this.windows = [];
        this.fireWindows = [];
        this.peopleWindows = [];
        this.life = 100;
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 3; col++) {
            const wx = this.x + 20 + col * 40;
            const wy = this.y + 30 + row * 50;
            this.windows.push({x: wx, y: wy, w: 30, h: 35});
            if (Math.random() < 0.5 + gameState.level * 0.02) {
              this.fireWindows.push({x: wx+5, y: wy+5, idx: this.windows.length-1});
              if (Math.random() < 0.6) this.peopleWindows.push({idx: this.windows.length-1, wave: 0});
            }
          }
        }
        this.time = 0;
      }
      update(dt) {
        this.time += dt;
        this.fireWindows.forEach(fw => {
          // Animate fire particles
          if (Math.random() < 0.3) {
            for (let i = 0; i < 5; i++) {
              gameState.particles.push(new Particle(fw.x + 15 + Math.random()*10, fw.y + 30, 'fire', 0, -1 - Math.random()));
            }
          }
          if (Math.random() < 0.1) gameState.particles.push(new Particle(this.x + this.width/2, this.y, 'smoke', (Math.random()-0.5)*2, -2));
        });
        this.peopleWindows.forEach(pw => pw.wave += dt * 3);
        return this.life > 0;
      }
      draw() {
        // Building body with glow
        ctx.shadowColor = '#ff4400';
        ctx.shadowBlur = 15;
        ctx.fillStyle = `hsl(0, 50%, ${10 + Math.sin(gameState.time * 0.01) * 5}%)`;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        
        // Windows
        this.windows.forEach((w, i) => {
          ctx.shadowBlur = 0;
          if (this.fireWindows.some(f => f.idx === i)) {
            // Fire glow
            ctx.shadowColor = '#ff8800';
            ctx.shadowBlur = 20;
            ctx.fillStyle = `hsl(${20 + Math.sin(gameState.time + w.x) * 10}, 100%, 60%)`;
          } else {
            ctx.fillStyle = '#112';
            ctx.strokeStyle = '#445';
            ctx.lineWidth = 1;
          }
          ctx.fillRect(w.x, w.y, w.w, w.h);
          ctx.strokeRect(w.x, w.y, w.w, w.h);
        });

        // People
        this.peopleWindows.forEach(pw => {
          const w = this.windows[pw.idx];
          ctx.save();
          ctx.translate(w.x + 15, w.y + 25);
          ctx.rotate(Math.sin(pw.wave) * 0.2);
          // Head
          ctx.fillStyle = '#ffddaa';
          ctx.beginPath();
          ctx.arc(0, -8, 5, 0, Math.PI*2);
          ctx.fill();
          // Body
          ctx.fillStyle = '#aa4400';
          ctx.fillRect(-3, -3, 6, 15);
          // Arms wave
          ctx.strokeStyle = '#aa4400';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(0, 2);
          ctx.lineTo(-8 * Math.sin(pw.wave), 8 + 5 * Math.cos(pw.wave));
          ctx.stroke();
          ctx.beginPath();
          ctx.moveTo(0, 2);
          ctx.lineTo(8 * Math.sin(pw.wave), 8 - 5 * Math.cos(pw.wave));
          ctx.stroke();
          ctx.restore();
        });

        ctx.shadowBlur = 0;
      }
      save() {
        // Extinguish + save people
        let people = this.peopleWindows.length;
        if (people > 0) {
          gameState.saved += people;
          gameState.money += people * 100 * gameState.combo * gameState.upgrades.ladder;
          gameState.combo++;
          gameState.comboTime = 120;
          showCombo(people);
        }
        gameState.money += this.fireWindows.length * 20 * gameState.upgrades.hose;
        // Sparks
        for (let i = 0; i < 20; i++) {
          gameState.particles.push(new Particle(this.x + this.width/2, this.y + this.height/2, 'spark', (Math.random()-0.5)*10, -Math.random()*10));
        }
        return true;
      }
    }

    // Boss Building
    let boss = null;
    function spawnBoss() {
      gameState.bossActive = true;
      gameState.bossHP = 200 + gameState.level * 20;
      boss = {
        x: cw/2 - 300,
        y: ch - 600,
        width: 600,
        height: 550,
        windows: [],
        fireWindows: [],
        peopleWindows: [],
        time: 0
      };
      for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
          const wx = boss.x + 30 + col * 60;
          const wy = boss.y + 40 + row * 60;
          boss.windows.push({x: wx, y: wy, w: 45, h: 45});
          boss.fireWindows.push({x: wx+8, y: wy+8, idx: boss.windows.length-1});
          if (Math.random() < 0.8) boss.peopleWindows.push({idx: boss.windows.length-1, wave: 0});
        }
      }
      document.getElementById('boss-hp').style.display = 'block';
    }

    function updateBoss(dt) {
      boss.time += dt;
      boss.fireWindows.forEach(fw => {
        for (let i = 0; i < 8; i++) gameState.particles.push(new Particle(fw.x + 22, fw.y + 35, 'fire', 0, -2));
      });
      boss.peopleWindows.forEach(pw => pw.wave += dt * 2);
    }

    function drawBoss() {
      // Massive glow
      ctx.shadowColor = '#ff2200';
      ctx.shadowBlur = 50;
      ctx.fillStyle = '#220';
      ctx.fillRect(boss.x, boss.y, boss.width, boss.height);
      
      boss.windows.forEach((w, i) => {
        ctx.shadowBlur = 25;
        ctx.shadowColor = '#ffaa00';
        ctx.fillStyle = `hsl(${15 + Math.sin(boss.time * 0.02 + w.x * 0.01) * 8}, 100%, 55%)`;
        ctx.fillRect(w.x, w.y, w.w, w.h);
      });

      // People like in building
      boss.peopleWindows.forEach(pw => {
        const w = boss.windows[pw.idx];
        ctx.save();
        ctx.translate(w.x + 22, w.y + 22);
        ctx.rotate(Math.sin(pw.wave) * 0.3);
        ctx.fillStyle = '#ffddaa';
        ctx.beginPath();
        ctx.arc(0, -10, 7, 0, Math.PI*2);
        ctx.fill();
        ctx.fillStyle = '#aa4400';
        ctx.fillRect(-4, -5, 8, 20);
        ctx.strokeStyle = '#aa4400';
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(-12 * Math.sin(pw.wave), 12 + 8 * Math.cos(pw.wave));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(12 * Math.sin(pw.wave), 12 - 8 * Math.cos(pw.wave));
        ctx.stroke();
        ctx.restore();
      });
      ctx.shadowBlur = 0;
    }

    function hitBoss(x, y) {
      gameState.bossHP -= 10 * gameState.upgrades.hose;
      document.getElementById('boss-hp-fill').style.width = (gameState.bossHP / (200 + gameState.level*20) * 100) + '%';
      gameState.shake = 20;
      for (let i = 0; i < 30; i++) {
        gameState.particles.push(new Particle(x, y, 'spark', (Math.random()-0.5)*20, -Math.random()*15));
      }
      if (gameState.bossHP <= 0) {
        gameState.bossActive = false;
        gameState.money += 20000;
        gameState.level += 2;
        document.getElementById('boss-hp').style.display = 'none';
        showPopup('–ë–û–°–° –ü–û–ë–ï–ñ–î–Å–ù!', cw/2, ch/2, '#ffff00', 60);
      }
    }

    // Weather Rain
    function spawnRain() {
      if (gameState.weather !== 'rain') return;
      for (let i = 0; i < 5; i++) {
        gameState.rain.push({
          x: Math.random() * cw,
          y: 0,
          vy: 15 + Math.random() * 10,
          life: 1
        });
      }
    }

    // HUD Updates
    function updateHUD() {
      document.getElementById('level').textContent = gameState.level;
      document.getElementById('saved').textContent = gameState.saved;
      document.getElementById('lives').textContent = '‚ù§Ô∏è'.repeat(gameState.lives);
      document.getElementById('combo').textContent = gameState.combo;
      document.getElementById('money').textContent = gameState.money.toLocaleString();
      if (gameState.saved > gameState.level * 25) {
        gameState.level++;
        updateRank();
      }
    }

    function updateRank() {
      const ranks = ['–ù–û–í–ò–ß–û–ö', '–ü–û–ñ–ê–†–ù–´–ô', '–°–¢–ê–†–®–ò–ù–ê', '–ö–ê–ü–ò–¢–ê–ù', '–ú–ê–ô–û–†', '–ì–ï–†–û–ô', '–ú–ê–†–®–ê–õ üî•'];
      const rankIdx = Math.min(Math.floor((gameState.level - 1) / 10), ranks.length - 1);
      document.getElementById('rank').textContent = ranks[rankIdx];
    }

    // Effects
    function showPopup(text, x, y, color, size = 40) {
      // Floating text animation via particles or ctx
      ctx.fillStyle = color;
      ctx.font = `${size}px Orbitron`;
      ctx.textAlign = 'center';
      ctx.shadowColor = color;
      ctx.shadowBlur = 30;
      let a = 1;
      const anim = () => {
        ctx.save();
        ctx.globalAlpha = a;
        ctx.fillText(text, x, y);
        ctx.restore();
        a -= 0.05;
        if (a > 0) requestAnimationFrame(anim);
      };
      anim();
    }

    function showCombo(people) {
      showPopup(`√ó${gameState.combo} –°–ü–ê–°–ï–ù–û!`, cw/2, 200, '#00ff00', 50);
    }

    // Main Loop
    let lastTime = 0;
    function loop(time) {
      const dt = time - lastTime;
      lastTime = time;

      // Clear with trail effect
      ctx.fillStyle = 'rgba(0,0,20,0.1)';
      ctx.fillRect(0, 0, cw, ch);

      // Shake
      ctx.save();
      if (gameState.shake > 0) {
        ctx.translate((Math.random() - 0.5) * gameState.shake, (Math.random() - 0.5) * gameState.shake);
        gameState.shake *= 0.9;
      }

      // Background stars/parallax
      ctx.fillStyle = '#fff';
      ctx.shadowBlur = 10;
      ctx.shadowColor = '#aaa';
      for (let i = 0; i < 100; i++) {
        const star = (Math.sin(time * 0.001 + i) + 1) / 2;
        ctx.globalAlpha = star * 0.5;
        ctx.fillRect(i * 10 % cw, (i * 15 + time * 0.1) % ch, 2, 2);
      }
      ctx.shadowBlur = 0;

      // Rain
      spawnRain();
      gameState.rain.forEach((drop, i) => {
        drop.y += drop.vy;
        drop.life -= 0.01;
        ctx.strokeStyle = `rgba(0,150,255,${drop.life})`;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(drop.x, drop.y);
        ctx.lineTo(drop.x + 5, drop.y + 10);
        ctx.stroke();
        if (drop.y > ch || drop.life <= 0) gameState.rain.splice(i, 1);
      });

      // Particles
      gameState.particles.forEach((p, i) => {
        p.update();
        p.draw();
        if (p.life <= 0) gameState.particles.splice(i, 1);
      });

      // Buildings
      if (!gameState.bossActive) {
        gameState.buildings.forEach((b, i) => {
          if (!b.update(dt)) {
            // Burned - lose life if people
            if (b.peopleWindows.length > 0) loseLife();
            gameState.buildings.splice(i, 1);
          } else b.draw();
        });
        if (gameState.buildings.length < 3 + gameState.level * 0.5 && Math.random() < 0.02) {
          gameState.buildings.push(new Building());
        }
      } else {
        updateBoss(dt);
        drawBoss();
      }

      // Truck - animated at bottom
      drawTruck();

      ctx.restore();

      // Combo decay
      if (gameState.comboTime > 0) gameState.comboTime--;
      else gameState.combo = 1;

      updateHUD();

      if (gameState.gameActive) requestAnimationFrame(loop);
    }

    function drawTruck() {
      const truckX = (cw / 2) + Math.sin(gameState.time * 0.005) * 100;
      ctx.save();
      ctx.translate(truckX, ch - 120);
      
      // Body glow
      ctx.shadowColor = '#ff4400';
      ctx.shadowBlur = 20;
      
      // Cab
      ctx.fillStyle = '#cc0000';
      ctx.fillRect(-60, -40, 80, 50);
      // Bed
      ctx.fillStyle = '#aa0000';
      ctx.fillRect(-100, -25, 140, 35);
      
      // Wheels animate
      const wheelRot = gameState.time * 0.1;
      ctx.fillStyle = '#333';
      ctx.beginPath();
      ctx.arc(-70, -5, 18, 0, Math.PI*2);
      ctx.fill();
      ctx.lineWidth = 4;
      ctx.strokeStyle = '#fff';
      ctx.stroke();
      ctx.save();
      ctx.rotate(wheelRot);
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI*2);
      ctx.fillStyle = '#111';
      ctx.fill();
      ctx.restore();
      
      ctx.beginPath();
      ctx.arc(60, -5, 18, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.save();
      ctx.rotate(-wheelRot);
      ctx.beginPath();
      ctx.arc(0, 0, 12, 0, Math.PI*2);
      ctx.fillStyle = '#111';
      ctx.fill();
      ctx.restore();
      
      // Siren glow
      ctx.shadowBlur = 30;
      ctx.shadowColor = '#00ff00';
      ctx.fillStyle = `hsl(120, 100%, ${50 + Math.sin(gameState.time * 0.2) * 25}%)`;
      ctx.fillRect(-20, -55, 40, 15);
      
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    // Input
    canvas.addEventListener('click', (e) => {
      if (!gameState.gameActive) return;
      const rect = canvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const y = e.clientY - rect.top;

      // Check hit building
      for (let b of gameState.buildings) {
        if (x > b.x && x < b.x + b.width && y > b.y && y < b.y + b.height) {
          b.save();
          gameState.buildings = gameState.buildings.filter(bb => bb !== b);
          Telegram.WebApp.HapticFeedback.impactOccurred('heavy');
          return;
        }
      }

      // Boss windows
      if (gameState.bossActive && x > boss.x && x < boss.x + boss.width && y > boss.y && y < boss.y + boss.height) {
        hitBoss(x, y);
        Telegram.WebApp.HapticFeedback.impactOccurred('strong');
      }
    });

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      const touch = e.touches[0];
      const rect = canvas.getBoundingClientRect();
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      // Same as click
      // ... (copy click logic)
    });

    // Hero switch
    document.querySelectorAll('.hero-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelector('.hero-btn.active').classList.remove('active');
        btn.classList.add('active');
        gameState.activeHero = parseInt(btn.dataset.hero);
      });
    });

    function loseLife() {
      gameState.lives--;
      if (gameState.lives <= 0) {
        gameState.gameActive = false;
        Telegram.WebApp.showAlert(`–ü–†–û–í–ê–õ! –£—Ä–æ–≤–µ–Ω—å ${gameState.level}\n–°–ø–∞—Å–µ–Ω–æ: ${gameState.saved}`);
        showMenu();
      }
      gameState.shake = 30;
    }

    // Upgrades
    function buyUpgrade(type) {
      const costs = {hose:500, ladder:2000, auto:10000, life:5000};
      if (gameState.money >= costs[type]) {
        gameState.money -= costs[type];
        if (type === 'hose') gameState.upgrades.hose += 0.5;
        if (type === 'ladder') gameState.upgrades.ladder++;
        if (type === 'auto') gameState.upgrades.auto = true;
        if (type === 'life') gameState.lives++;
      }
    }

    // Menu functions
    function startGame() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('shop').style.display = 'none';
      gameState.gameActive = true;
      gameState.buildings = [];
      gameState.particles = [];
      gameState.rain = [];
      gameState.level = 1;
      gameState.saved = 0;
      gameState.lives = 3 + gameState.upgrades.lives;
      gameState.combo = 1;
      gameState.bossActive = false;
      requestAnimationFrame(loop);
    }

    function openShop() {
      document.getElementById('menu').style.display = 'none';
      document.getElementById('shop').style.display = 'flex';
    }

    function closeShop() {
      document.getElementById('shop').style.display = 'none';
      document.getElementById('menu').style.display = 'flex';
    }

    function showMenu() {
      document.getElementById('menu').style.display = 'flex';
    }

    // Auto save if upgrade
    setInterval(() => {
      if (gameState.upgrades.auto && gameState.gameActive) {
        // Simulate auto hit on nearest building
        if (gameState.buildings.length > 0) {
          gameState.buildings[0].save();
          gameState.buildings.shift();
        }
      }
    }, 2000);

    // Weather cycle
    setInterval(() => {
      if (Math.random() < 0.3) {
        gameState.weather = 'rain';
        setTimeout(() => gameState.weather = 'clear', 10000);
      }
    }, 20000);

    // Boss spawn every 10 levels
    setInterval(() => {
      if (gameState.level % 10 === 0 && !gameState.bossActive && gameState.gameActive) {
        spawnBoss();
      }
    }, 1000);

    // Init
    window.onload = () => {
      gameState.time = 0;
      showMenu();
    };

    // Global time
    setInterval(() => gameState.time += 16, 16);
  </script>
</body>
</html>
