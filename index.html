<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>INFERNO: RED SKY</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700;900&display=swap');

        :root {
            --glass: rgba(15, 20, 30, 0.6);
            --border: rgba(255, 255, 255, 0.15);
            --accent: #ff3b3b;
            --neon-blue: #00f7ff;
        }

        body {
            margin: 0;
            background: #000;
            overflow: hidden;
            font-family: 'Exo 2', sans-serif;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI LAYOUT */
        #ui {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        /* TOP HUD */
        .hud {
            display: flex;
            justify-content: space-between;
            padding: max(15px, env(safe-area-inset-top)) 20px 0 20px;
        }

        .widget {
            background: var(--glass);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            border-radius: 16px;
            padding: 8px 16px;
            display: flex;
            flex-direction: column;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .widget-label {
            font-size: 10px;
            color: #8a9bb5;
            font-weight: 700;
            letter-spacing: 1px;
            margin-bottom: 4px;
        }

        .widget-val {
            font-size: 20px;
            color: #fff;
            font-weight: 900;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
        }

        .bar-track {
            width: 100px;
            height: 6px;
            background: rgba(0,0,0,0.5);
            border-radius: 3px;
            overflow: hidden;
            margin-top: 2px;
        }
        .bar-fill { height: 100%; transition: width 0.1s linear; }
        .fill-water { background: linear-gradient(90deg, #00a8ff, var(--neon-blue)); box-shadow: 0 0 10px var(--neon-blue); }
        .fill-heat { background: linear-gradient(90deg, #ff8800, #ff0000); box-shadow: 0 0 10px #ff0000; }

        /* VIGNETTE & CINEMATIC */
        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 150%);
            pointer-events: none;
            z-index: 5;
        }
        
        /* CONTROLS */
        .controls-layer {
            padding: 20px;
            padding-bottom: max(30px, env(safe-area-inset-bottom));
            pointer-events: auto;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
        }

        .btn-group { position: relative; width: 160px; height: 160px; }

        .btn {
            position: absolute;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            backdrop-filter: blur(4px);
            border-radius: 50%;
            display: flex; justify-content: center; align-items: center;
            color: #fff; font-size: 24px;
            transition: transform 0.1s, background 0.1s;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
        }
        .btn:active { transform: scale(0.9); background: rgba(255,255,255,0.15); border-color: #fff; }
        
        /* Layout D-Pad */
        .b-left { width: 60px; height: 60px; top: 50px; left: 0; }
        .b-right { width: 60px; height: 60px; top: 50px; right: 0; }
        .b-refill { 
            width: 80px; height: 40px; bottom: 0; left: 40px; 
            border-radius: 20px; font-size: 12px; font-weight: bold;
            border-color: var(--accent); color: var(--accent);
        }

        /* Layout Action */
        .b-up { width: 50px; height: 50px; top: 0; left: 55px; }
        .b-down { width: 50px; height: 50px; bottom: 0; left: 55px; }
        .b-shoot { 
            width: 90px; height: 90px; top: 35px; right: 0; 
            background: rgba(255, 59, 59, 0.15);
            border-color: rgba(255, 59, 59, 0.5);
            box-shadow: 0 0 25px rgba(255, 59, 59, 0.2);
        }
        .b-shoot:active { background: rgba(255, 59, 59, 0.4); }

        /* SCREENS */
        .modal-bg {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(20px);
            z-index: 100;
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none; transition: 0.3s;
        }
        .modal-bg.visible { opacity: 1; pointer-events: auto; }

        .card {
            width: 85%; max-width: 380px;
            background: linear-gradient(145deg, #1a1a24, #0b0b10);
            border: 1px solid #333;
            border-radius: 24px;
            padding: 32px;
            text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: translateY(20px); transition: 0.3s;
        }
        .visible .card { transform: translateY(0); }

        h1 { margin: 0 0 8px 0; font-size: 32px; background: linear-gradient(to bottom, #fff, #aaa); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }
        .subtitle { color: #666; font-size: 14px; margin-bottom: 24px; }
        
        .cta-btn {
            width: 100%; padding: 16px; border: none; border-radius: 12px;
            background: linear-gradient(90deg, #3b82f6, #2563eb);
            color: #fff; font-weight: 800; font-size: 16px; letter-spacing: 1px;
            cursor: pointer; box-shadow: 0 5px 20px rgba(37, 99, 235, 0.4);
        }
        .cta-btn:active { transform: scale(0.98); }

        .shop-grid { display: grid; gap: 12px; margin: 20px 0; text-align: left; }
        .shop-item {
            background: rgba(255,255,255,0.03); border: 1px solid #333;
            padding: 12px; border-radius: 12px;
            display: flex; justify-content: space-between; align-items: center;
        }
        .shop-item.locked { opacity: 0.5; }
        .item-name { color: #fff; font-weight: bold; font-size: 14px; }
        .item-desc { color: #666; font-size: 10px; }
        .item-price { color: #ffd700; font-weight: 900; font-family: monospace; }

        /* FX */
        .flash {
            position: fixed; top:0; left:0; width:100%; height:100%;
            background: #fff; pointer-events: none; opacity: 0; z-index: 20;
        }
        @keyframes floatUp { 0%{opacity:1; transform:translateY(0);} 100%{opacity:0; transform:translateY(-50px);} }
        .float-msg {
            position: absolute; color: #fff; font-weight: 900; font-size: 24px;
            text-shadow: 0 2px 10px rgba(0,0,0,0.5); pointer-events: none;
            animation: floatUp 0.8s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }
    </style>
</head>
<body>
    <div class="vignette"></div>
    <div class="flash" id="flash-fx"></div>
    <canvas id="cvs"></canvas>

    <div id="ui">
        <div class="hud">
            <div class="widget">
                <div class="widget-label">PRESSURE</div>
                <div class="bar-track"><div class="bar-fill fill-water" id="ui-water"></div></div>
            </div>
            <div class="widget" style="min-width: 100px; align-items: center;">
                <div class="widget-label">CAPITAL</div>
                <div class="widget-val" id="ui-money">$0</div>
            </div>
            <div class="widget">
                <div class="widget-label">CHAOS LEVEL</div>
                <div class="bar-track"><div class="bar-fill fill-heat" id="ui-heat"></div></div>
            </div>
        </div>

        <div id="fx-layer" style="position:absolute; width:100%; height:100%;"></div>

        <div class="controls-layer">
            <div class="btn-group">
                <div id="btn-l" class="btn b-left">‚Üê</div>
                <div id="btn-r" class="btn b-right">‚Üí</div>
                <div id="btn-refill" class="btn b-refill">REFILL</div>
            </div>
            <div class="btn-group">
                <div id="btn-u" class="btn b-up">‚Üë</div>
                <div id="btn-d" class="btn b-down">‚Üì</div>
                <div id="btn-shoot" class="btn b-shoot"></div>
            </div>
        </div>
    </div>

    <!-- START -->
    <div id="screen-start" class="modal-bg visible">
        <div class="card">
            <h1>INFERNO</h1>
            <div class="subtitle">REALISTIC FIRE SIMULATOR</div>
            <div style="margin-bottom: 30px; font-size: 12px; line-height: 1.6; color: #888;">
                ‚Ä¢ Realistic Fluid Physics<br>
                ‚Ä¢ Dynamic Weather & Lighting<br>
                ‚Ä¢ Save Civilians to earn Capital
            </div>
            <button class="cta-btn" onclick="Game.start()">DEPLOY UNIT</button>
        </div>
    </div>

    <!-- SHOP -->
    <div id="screen-shop" class="modal-bg">
        <div class="card">
            <h1 style="font-size: 24px;">SECTOR CLEARED</h1>
            <div id="shop-msg" class="subtitle">Mission Report...</div>
            
            <div class="shop-grid">
                <div class="shop-item" onclick="Game.buy('pressure')">
                    <div>
                        <div class="item-name">HIGH PRESSURE PUMP</div>
                        <div class="item-desc" id="lvl-pressure">Increases Range</div>
                    </div>
                    <div class="item-price" id="price-pressure">$200</div>
                </div>
                <div class="shop-item" onclick="Game.buy('tank')">
                    <div>
                        <div class="item-name">TITANIUM TANK</div>
                        <div class="item-desc" id="lvl-tank">Capacity +50%</div>
                    </div>
                    <div class="item-price" id="price-tank">$300</div>
                </div>
                <div class="shop-item" onclick="Game.buy('engine')">
                    <div>
                        <div class="item-name">TURBO DIESEL</div>
                        <div class="item-desc" id="lvl-engine">Movement Speed</div>
                    </div>
                    <div class="item-price" id="price-engine">$400</div>
                </div>
            </div>
            <button class="cta-btn" onclick="Game.nextLevel()">NEXT SECTOR</button>
        </div>
    </div>

    <script>
        // === CORE ENGINE ===
        const cvs = document.getElementById('cvs');
        const ctx = cvs.getContext('2d', { alpha: false, desynchronized: true });
        
        // CONFIG
        const CFG = {
            gravity: 0.25,
            groundY: 0,
            particles: 1500,
            colors: {
                fire: ['#ff4d00', '#ffaa00', '#ffcc00'],
                smoke: ['#111', '#222', '#333'],
                water: '#aeefff'
            }
        };

        // STATE
        const State = {
            money: 0,
            level: 1,
            upgrades: { pressure: 1, tank: 1, engine: 1 },
            load() {
                const d = localStorage.getItem('inferno_real_v1');
                if(d) {
                    const p = JSON.parse(d);
                    this.money = p.money;
                    this.level = p.level;
                    this.upgrades = p.upgrades;
                }
            },
            save() {
                localStorage.setItem('inferno_real_v1', JSON.stringify({
                    money: this.money, level: this.level, upgrades: this.upgrades
                }));
            }
        };
        State.load();

        // RESIZE & H-DPI
        let W, H, DPR;
        const resize = () => {
            W = window.innerWidth;
            H = window.innerHeight;
            DPR = Math.min(2, window.devicePixelRatio);
            cvs.width = W * DPR;
            cvs.height = H * DPR;
            ctx.scale(DPR, DPR);
            CFG.groundY = H - 60;
        };
        window.addEventListener('resize', resize);
        resize();

        // === OBJECT POOLING (OPTIMIZATION) ===
        class Particle {
            constructor() { this.active = false; }
            spawn(x, y, type, vx, vy, size) {
                this.x = x; this.y = y;
                this.vx = vx; this.vy = vy;
                this.type = type; // 0: water, 1: fire, 2: smoke, 3: spark, 4: steam
                this.life = 1.0;
                this.size = size;
                this.active = true;
                this.seed = Math.random();
            }
        }

        const Pool = {
            items: new Array(CFG.particles).fill().map(() => new Particle()),
            get(x, y, type, vx, vy, size) {
                for(let i=0; i<this.items.length; i++) {
                    if(!this.items[i].active) {
                        this.items[i].spawn(x, y, type, vx, vy, size);
                        return;
                    }
                }
            }
        };

        // === GAME ENTITIES ===
        const Camera = { x: 0, shake: 0 };

        class Building {
            constructor(x, w, h) {
                this.x = x; this.w = w; this.h = h;
                this.windows = [];
                const rows = Math.floor(h / 70);
                const cols = Math.floor(w / 45);
                for(let r=0; r<rows; r++) {
                    for(let c=0; c<cols; c++) {
                        this.windows.push({
                            x: x + 10 + c*45,
                            y: CFG.groundY - (r*70) - 60,
                            w: 30, h: 45,
                            hp: 0, // 0-100 fire
                            max: 100,
                            person: Math.random() < 0.25,
                            saved: false, dead: false
                        });
                    }
                }
            }

            draw(ctx, camX) {
                // Realistic Window Reflection/Interior
                ctx.fillStyle = '#050505';
                ctx.fillRect(this.x - camX, CFG.groundY - this.h, this.w, this.h);
                
                // Building Texture (Subtle grid)
                ctx.strokeStyle = '#1a1a20';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x - camX, CFG.groundY - this.h, this.w, this.h);

                this.windows.forEach(w => {
                    let wx = w.x - camX;
                    
                    // Window State
                    if(w.hp >= 100) {
                        ctx.fillStyle = '#000'; // Burnt
                    } else if(w.hp > 0) {
                        // Interior Glow
                        let flick = 0.5 + Math.random()*0.5;
                        ctx.fillStyle = `rgba(255, ${150 - w.hp}, 50, ${flick})`;
                        
                        // Emit Particles
                        if(Math.random() < w.hp/300) {
                            Pool.get(w.x + Math.random()*w.w, w.y + w.h, 1, (Math.random()-0.5)*2, -2 - Math.random()*2, 10 + Math.random()*15);
                            if(Math.random() < 0.3) Pool.get(w.x + w.w/2, w.y, 2, (Math.random()-0.5)+Game.wind, -1, 20);
                        }
                    } else {
                        ctx.fillStyle = '#0a0e14'; // Dark glass
                        // Fake Reflection
                        ctx.fillStyle = `rgba(20, 30, 50, ${0.3 + Math.random()*0.1})`;
                    }
                    
                    ctx.fillRect(wx, w.y, w.w, w.h);
                    
                    // Frame
                    ctx.strokeStyle = '#222';
                    ctx.strokeRect(wx, w.y, w.w, w.h);

                    // Person
                    if(w.person && !w.saved && !w.dead) {
                        ctx.fillStyle = '#fff';
                        ctx.font = '20px Arial';
                        ctx.fillText('üôã', wx + 5, w.y + 35);
                        if(w.hp > 0) {
                            ctx.fillStyle = '#f33';
                            ctx.font = 'bold 10px Arial';
                            ctx.fillText('HELP', wx + 2, w.y - 5);
                        }
                    }
                });
            }
        }

        const Truck = {
            x: 100, y: 0, w: 130, h: 45, angle: -0.5,
            water: 100, maxWater: 100,
            color: '#e62e2e',
            update() {
                this.y = CFG.groundY - 55;
                let spd = 3 + State.upgrades.engine;
                if(Input.l && this.x > 50) this.x -= spd;
                if(Input.r && this.x < Game.width - 150) this.x += spd;
                
                if(Input.u && this.angle > -2.2) this.angle -= 0.05;
                if(Input.d && this.angle < -0.1) this.angle += 0.05;

                // Camera Follow
                let targetCam = this.x - W/2 + this.w/2;
                Camera.x += (targetCam - Camera.x) * 0.1; // Smooth pan
                Camera.x = Math.max(0, Math.min(Camera.x, Game.width - W));

                // Refill
                if(Input.refill) {
                    if(this.x < 150) {
                        this.water = Math.min(this.water + 1.5, this.maxWater);
                    } else {
                        UI.msg('HYDRANT IS AT START!', this.x - Camera.x, this.y - 50);
                    }
                }

                // Shoot
                if(Input.shoot && this.water > 0) {
                    this.water -= 0.4;
                    if(Math.random()>0.5 && navigator.vibrate) navigator.vibrate(5);
                    
                    let pow = 12 + State.upgrades.pressure * 3;
                    let nx = this.x + 80, ny = this.y;
                    
                    // Water Physics Scatter
                    let spread = 0.05;
                    Pool.get(nx, ny, 0, 
                        Math.cos(this.angle + (Math.random()-0.5)*spread) * pow,
                        Math.sin(this.angle + (Math.random()-0.5)*spread) * pow,
                        3 + Math.random()*3
                    );
                }
            },
            draw(ctx, camX) {
                let tx = this.x - camX;
                
                // Shadow
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(tx + 10, this.y + 45, this.w - 20, 8);

                // Body
                ctx.fillStyle = this.color;
                ctx.fillRect(tx, this.y, this.w, this.h);
                
                // Details
                ctx.fillStyle = '#fff';
                ctx.fillRect(tx, this.y + 15, this.w, 8); // Stripe
                ctx.fillStyle = '#111';
                ctx.fillRect(tx + 5, this.y + 5, 20, 35); // Grill

                // Cannon
                ctx.save();
                ctx.translate(tx + 80, this.y + 5);
                ctx.rotate(this.angle);
                ctx.fillStyle = '#888';
                ctx.fillRect(0, -6, 40, 12);
                ctx.restore();

                // Wheels
                ctx.fillStyle = '#1a1a1a';
                let wheelY = this.y + 40;
                ctx.beginPath(); ctx.arc(tx + 30, wheelY, 14, 0, Math.PI*2); ctx.fill();
                ctx.beginPath(); ctx.arc(tx + 100, wheelY, 14, 0, Math.PI*2); ctx.fill();
                
                // Lights (Flashing)
                if(Math.floor(Date.now()/100)%2===0) {
                    ctx.fillStyle = '#f00';
                    ctx.shadowBlur = 20; ctx.shadowColor = 'red';
                    ctx.fillRect(tx + 15, this.y - 8, 20, 8);
                    ctx.shadowBlur = 0;
                }
            }
        };

        // === LOGIC ===
        const Game = {
            running: false,
            buildings: [],
            width: 2000,
            wind: 0,
            heat: 0,
            maxHeat: 1000,

            start() {
                document.querySelector('.visible').classList.remove('visible');
                this.loadLevel();
                this.running = true;
                Loop();
            },

            loadLevel() {
                this.buildings = [];
                this.heat = 0;
                this.wind = (Math.random() - 0.5) * (1 + State.level*0.5);
                this.width = 1500 + State.level * 500;
                Truck.maxWater = 100 + State.upgrades.tank * 50;
                Truck.water = Truck.maxWater;
                Truck.x = 80;

                // Generate City
                let bx = 250;
                let count = 2 + Math.ceil(State.level/2);
                for(let i=0; i<count; i++) {
                    let w = 100 + Math.random()*150;
                    let h = 200 + Math.random() * (100 + State.level*20);
                    this.buildings.push(new Building(bx, w, h));
                    bx += w + 50 + Math.random()*100;
                }

                // Ignite
                let targets = this.buildings.flatMap(b => b.windows);
                let fires = 3 + State.level;
                for(let i=0; i<fires; i++) {
                    targets[Math.floor(Math.random()*targets.length)].hp = 50;
                }
            },

            update() {
                Truck.update();

                // Particles
                Pool.items.forEach(p => {
                    if(!p.active) return;
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.01;

                    if(p.type === 0) { // Water
                        p.vy += CFG.gravity; // Gravity
                        p.vx += this.wind * 0.05;
                        
                        // Collision
                        if(p.y > CFG.groundY) { p.active = false; return; } // Ground
                        
                        // Check Windows
                        this.buildings.forEach(b => {
                            if(p.x > b.x && p.x < b.x + b.w) {
                                b.windows.forEach(w => {
                                    if(w.hp > 0 && w.hp < 100 && p.x > w.x && p.x < w.x+w.w && p.y > w.y && p.y < w.y+w.h) {
                                        p.active = false;
                                        w.hp -= 1.5;
                                        // Steam
                                        Pool.get(p.x, p.y, 4, (Math.random()-0.5)*2, -1, 15);
                                        
                                        if(w.hp <= 0) {
                                            w.hp = 0;
                                            State.money += 15;
                                            UI.msg('+$15', w.x - Camera.x, w.y);
                                            if(w.person && !w.saved) {
                                                w.saved = true;
                                                State.money += 100;
                                                UI.msg('SAVED! +$100', w.x-Camera.x, w.y-20, '#0f0');
                                                if(navigator.vibrate) navigator.vibrate([50,50,50]);
                                            }
                                        }
                                    }
                                });
                            }
                        });

                    } else if(p.type === 1) { // Fire
                        p.vy += -0.05; // Rise
                        p.size *= 0.97;
                        if(p.life < 0.1) p.active = false;
                    } else if(p.type === 2) { // Smoke
                        p.vx += this.wind * 0.1;
                        p.size *= 1.02;
                        p.life -= 0.005; // Smoke lasts longer
                    } else if (p.type === 4) { // Steam
                        p.vy -= 0.1;
                        p.size *= 1.05;
                        p.life -= 0.02;
                    }

                    if(p.life <= 0) p.active = false;
                });

                // Simulation
                let burning = 0;
                this.buildings.forEach(b => {
                    b.windows.forEach(w => {
                        if(w.hp > 0 && w.hp < 100) {
                            burning++;
                            w.hp += 0.05 + (State.level * 0.01);
                            this.heat += 0.05;
                            
                            if(w.hp >= 100) {
                                w.hp = 100;
                                if(w.person && !w.saved && !w.dead) {
                                    w.dead = true;
                                    this.heat += 150;
                                    UI.msg('LOST!', w.x - Camera.x, w.y, '#f00');
                                }
                            }
                        }
                    });
                });

                // Win Condition
                if(burning === 0 && Pool.items.filter(p => p.active && p.type===0).length === 0) {
                    if(!this.winTimer) this.winTimer = setTimeout(() => this.finish(), 1500);
                } else {
                    this.winTimer = null;
                }

                if(this.heat > this.maxHeat) this.heat = this.maxHeat; // Cap heat
            },

            draw() {
                // Dynamic Sky Color based on Heat
                let heatRatio = this.heat / this.maxHeat;
                let r = 20 + heatRatio * 60; 
                let b = 30 - heatRatio * 20;
                ctx.fillStyle = `rgb(${r}, 10, ${b})`;
                ctx.fillRect(0, 0, W, H);

                // Stars (Parallax)
                ctx.fillStyle = 'rgba(255,255,255,0.5)';
                for(let i=0; i<60; i++) {
                    let sx = (i * 40 - Camera.x * 0.1) % W;
                    if(sx < 0) sx += W;
                    ctx.fillRect(sx, (i*13)%H/2, 1, 1);
                }

                // === REFLECTION PASS (The "Realism" Hack) ===
                // We draw buildings and fire upside down, masked, with low opacity
                ctx.save();
                ctx.translate(0, CFG.groundY * 2);
                ctx.scale(1, -1);
                ctx.globalAlpha = 0.3;
                
                this.buildings.forEach(b => b.draw(ctx, Camera.x));
                // Draw only Fire/Water particles in reflection
                Pool.items.forEach(p => {
                    if(!p.active || (p.type !== 1 && p.type !== 0)) return;
                    ctx.fillStyle = p.type === 1 ? '#f80' : '#0ff';
                    ctx.beginPath(); ctx.arc(p.x - Camera.x, p.y, p.size, 0, Math.PI*2); ctx.fill();
                });
                ctx.restore();

                // Ground Line
                ctx.fillStyle = '#0a0a0c';
                ctx.fillRect(0, CFG.groundY, W, H - CFG.groundY);
                
                // Wet Asphalt Shine
                let grad = ctx.createLinearGradient(0, CFG.groundY, 0, CFG.groundY + 50);
                grad.addColorStop(0, `rgba(255, 100, 50, ${heatRatio * 0.3})`);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle = grad;
                ctx.fillRect(0, CFG.groundY, W, 50);

                // Hydrant
                let hyX = 100 - Camera.x;
                if(hyX > -50 && hyX < W+50) {
                    ctx.fillStyle = '#f22';
                    ctx.fillRect(hyX, CFG.groundY - 20, 15, 20);
                }

                // Main Draw Pass
                this.buildings.forEach(b => b.draw(ctx, Camera.x));
                Truck.draw(ctx, Camera.x);

                // Particles Draw
                Pool.items.forEach(p => {
                    if(!p.active) return;
                    let px = p.x - Camera.x;
                    if(px < -50 || px > W+50) return; // Culling

                    if(p.type === 1) { // Fire
                        ctx.globalCompositeOperation = 'lighter';
                        let colIdx = Math.floor(p.seed * 3);
                        ctx.fillStyle = CFG.colors.fire[colIdx];
                        ctx.globalAlpha = p.life;
                    } else if (p.type === 0) { // Water
                        ctx.globalCompositeOperation = 'screen';
                        ctx.fillStyle = CFG.colors.water;
                        ctx.globalAlpha = 0.8;
                    } else if (p.type === 2) { // Smoke
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.fillStyle = 'rgba(20,20,20,0.4)';
                        ctx.globalAlpha = p.life * 0.5;
                    } else { // Steam
                         ctx.globalCompositeOperation = 'overlay';
                         ctx.fillStyle = '#fff';
                         ctx.globalAlpha = p.life * 0.3;
                    }

                    ctx.beginPath();
                    ctx.arc(px, p.y, p.size, 0, Math.PI*2);
                    ctx.fill();
                });
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;

                // UI Sync
                document.getElementById('ui-water').style.width = (Truck.water / Truck.maxWater * 100) + '%';
                document.getElementById('ui-heat').style.width = (this.heat / this.maxHeat * 100) + '%';
                document.getElementById('ui-money').innerText = '$' + State.money;
            },

            finish() {
                this.running = false;
                State.save();
                document.getElementById('screen-shop').classList.add('visible');
                document.getElementById('shop-msg').innerText = `LEVEL ${State.level} COMPLETE. WIND: ${this.wind.toFixed(1)}`;
                this.updateShop();
            },

            buy(type) {
                let costs = { pressure: 200, tank: 300, engine: 400 };
                let cost = costs[type] * State.upgrades[type];
                
                if(State.money >= cost) {
                    State.money -= cost;
                    State.upgrades[type]++;
                    State.save();
                    UI.msg('UPGRADED', W/2, H/2, '#0f0');
                    this.updateShop();
                }
            },

            updateShop() {
                const u = State.upgrades;
                const c = { pressure: 200, tank: 300, engine: 400 };
                
                document.getElementById('lvl-pressure').innerText = `Lvl ${u.pressure} -> ${u.pressure+1}`;
                document.getElementById('price-pressure').innerText = '$'+(c.pressure * u.pressure);
                
                document.getElementById('lvl-tank').innerText = `Lvl ${u.tank} -> ${u.tank+1}`;
                document.getElementById('price-tank').innerText = '$'+(c.tank * u.tank);
                
                document.getElementById('lvl-engine').innerText = `Lvl ${u.engine} -> ${u.engine+1}`;
                document.getElementById('price-engine').innerText = '$'+(c.engine * u.engine);
            },

            nextLevel() {
                State.level++;
                State.save();
                document.getElementById('screen-shop').classList.remove('visible');
                this.start();
            }
        };

        // === INPUT ===
        const Input = { l:0, r:0, u:0, d:0, shoot:0, refill:0 };
        const bind = (id, k) => {
            const el = document.getElementById(id);
            const on = (e) => { e.preventDefault(); Input[k]=1; if(navigator.vibrate) navigator.vibrate(5); el.style.transform = 'scale(0.9)'; };
            const off = (e) => { e.preventDefault(); Input[k]=0; el.style.transform = 'scale(1)'; };
            el.addEventListener('touchstart', on, {passive:false});
            el.addEventListener('touchend', off);
            el.addEventListener('mousedown', on);
            el.addEventListener('mouseup', off);
        };
        bind('btn-l','l'); bind('btn-r','r'); bind('btn-u','u'); bind('btn-d','d');
        bind('btn-shoot','shoot'); bind('btn-refill','refill');

        const UI = {
            msg(txt, x, y, col='#fff') {
                const d = document.createElement('div');
                d.className = 'float-msg';
                d.innerText = txt;
                d.style.left = x + 'px';
                d.style.top = y + 'px';
                d.style.color = col;
                document.getElementById('fx-layer').appendChild(d);
                setTimeout(() => d.remove(), 800);
            }
        };

        // LOOP
        function Loop() {
            if(!Game.running) return;
            requestAnimationFrame(Loop);
            Game.update();
            Game.draw();
        }

        if(window.Telegram && window.Telegram.WebApp) {
            window.Telegram.WebApp.ready();
            window.Telegram.WebApp.expand();
        }
    </script>
</body>
</html>
