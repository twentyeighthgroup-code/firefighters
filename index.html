<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>HAZARD OPS: BLACKOUT</title>
    <style>
        /* --- CSS SYSTEM --- */
        @import url('https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap');

        :root {
            --bg: #020202;
            --ui-base: rgba(16, 20, 24, 0.95);
            --ui-border: #333;
            --accent: #e63946; /* Emergency Red */
            --primary: #457b9d; /* Tactical Blue */
            --success: #2a9d8f;
            --text-main: #f1faee;
            --scanline: rgba(0, 0, 0, 0.5);
        }

        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }

        body {
            margin: 0; background-color: var(--bg); overflow: hidden;
            font-family: 'Share Tech Mono', monospace; color: var(--text-main);
            width: 100vw; height: 100vh;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        /* CRT EFFECTS */
        .crt-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
        }
        .vignette {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 90;
            background: radial-gradient(circle, transparent 50%, black 120%);
        }

        /* UI LAYOUT */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 50; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between;
        }

        /* HUD */
        .hud-header {
            display: flex; justify-content: space-between; padding: 10px 20px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }
        .stat-mod {
            background: var(--ui-base); border: 1px solid var(--ui-border);
            padding: 5px 10px; border-left: 3px solid var(--primary);
            transform: skewX(-10deg); box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        .stat-mod.danger { border-left-color: var(--accent); animation: pulseRed 1s infinite; }
        .label { font-size: 10px; color: #888; text-transform: uppercase; }
        .value { font-size: 18px; font-weight: bold; }
        
        .bar-cnt { width: 80px; height: 6px; background: #222; margin-top: 4px; border: 1px solid #444; }
        .bar-fill { height: 100%; background: var(--primary); transition: width 0.2s; }

        /* CONTROLS */
        .controls {
            padding: 20px; pointer-events: auto; display: flex; justify-content: space-between; align-items: flex-end;
        }
        .stick-zone {
            width: 140px; height: 140px; position: relative;
            border: 1px dashed rgba(255,255,255,0.2); border-radius: 50%;
        }
        .knob {
            width: 50px; height: 50px; background: rgba(255,255,255,0.1); border: 1px solid #fff;
            border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }

        .action-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 15px; }
        .btn {
            width: 60px; height: 60px; background: rgba(20,20,20,0.8); border: 1px solid #555;
            border-radius: 12px; color: white; display: flex; justify-content: center; align-items: center;
            font-size: 24px; backdrop-filter: blur(4px); transition: 0.1s;
        }
        .btn:active { background: var(--primary); border-color: #fff; transform: scale(0.95); }
        .btn-lg { width: 70px; height: 70px; background: rgba(230, 57, 70, 0.2); border-color: var(--accent); }
        .btn-lg:active { background: var(--accent); }

        /* MENUS */
        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #050505;
            z-index: 200; display: flex; align-items: center; justify-content: center; transition: 0.3s;
        }
        .modal.hidden { opacity: 0; pointer-events: none; }
        
        .terminal {
            width: 90%; max-width: 600px; background: #0a0a0a; border: 1px solid #444;
            padding: 20px; position: relative; box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .terminal::before { content: ''; position: absolute; top:0; left:0; width:100%; height:4px; background: var(--accent); }
        
        .term-head { display: flex; justify-content: space-between; border-bottom: 1px solid #333; padding-bottom: 10px; margin-bottom: 20px; }
        .term-title { font-size: 24px; color: var(--accent); font-weight: bold; }
        
        .loadout-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-bottom: 20px; }
        .card {
            background: #111; border: 1px solid #333; padding: 10px; cursor: pointer; transition: 0.2s; opacity: 0.6;
        }
        .card:hover, .card.selected { border-color: var(--primary); opacity: 1; background: rgba(69, 123, 157, 0.1); }
        .card-icon { font-size: 24px; margin-bottom: 5px; }
        .card-name { font-size: 12px; font-weight: bold; color: #fff; }
        .card-desc { font-size: 9px; color: #888; margin-top: 5px; }

        .start-btn {
            width: 100%; padding: 15px; background: var(--accent); color: #fff; border: none;
            font-family: inherit; font-size: 18px; font-weight: bold; cursor: pointer;
            text-transform: uppercase; letter-spacing: 2px;
        }
        .start-btn:hover { background: #c92a35; }

        /* NOTIFICATIONS */
        .notify-area {
            position: absolute; top: 20%; width: 100%; text-align: center; pointer-events: none;
        }
        .msg {
            font-size: 20px; font-weight: bold; text-shadow: 0 2px 0 #000;
            animation: slideUp 1.5s forwards; color: #fff;
        }
        @keyframes slideUp { 0%{opacity:1; transform:translateY(0);} 100%{opacity:0; transform:translateY(-50px);} }
        @keyframes pulseRed { 0%{box-shadow:0 0 5px var(--accent);} 50%{box-shadow:0 0 20px var(--accent);} 100%{box-shadow:0 0 5px var(--accent);} }

    </style>
</head>
<body>

    <div class="crt-overlay"></div>
    <div class="vignette"></div>
    <canvas id="gameCanvas"></canvas>

    <!-- UI INTERFACE -->
    <div id="ui-layer">
        <div class="hud-header">
            <div class="stat-mod">
                <div class="label">SQUAD</div>
                <div class="value" id="ui-squad">ONLINE</div>
            </div>
            <div class="stat-mod" id="temp-mod">
                <div class="label">TEMP</div>
                <div class="value" id="ui-temp">24¬∞C</div>
            </div>
            <div class="stat-mod">
                <div class="label">OXYGEN</div>
                <div class="bar-cnt"><div class="bar-fill" id="ui-o2"></div></div>
            </div>
        </div>

        <div class="notify-area" id="notifications"></div>

        <div class="controls">
            <div class="stick-zone" id="joystick">
                <div class="knob" id="joy-knob"></div>
            </div>
            
            <div class="action-grid">
                <div class="btn" onclick="Game.toggleCommand()">üì°</div> <!-- Squad Command -->
                <div class="btn" onclick="Game.switchTool()">üîÑ</div> <!-- Switch Weapon -->
                <div class="btn" id="btn-interact" onmousedown="Input.action=true" onmouseup="Input.action=false" ontouchstart="Input.action=true" ontouchend="Input.action=false">üñêÔ∏è</div>
                <div class="btn btn-lg" id="btn-fire" onmousedown="Input.fire=true" onmouseup="Input.fire=false" ontouchstart="Input.fire=true" ontouchend="Input.fire=false">üî•</div>
            </div>
        </div>
    </div>

    <!-- LOADOUT MENU -->
    <div id="menu" class="modal">
        <div class="terminal">
            <div class="term-head">
                <span class="term-title">HAZARD OPS</span>
                <span style="font-size:10px; color:#666;">v3.5.0 sys_ready</span>
            </div>
            
            <div style="margin-bottom: 10px; color: #aaa; font-size: 12px;">SELECT SPECIALIZATION:</div>
            <div class="loadout-grid">
                <div class="card selected" onclick="Game.setClass('breacher', this)">
                    <div class="card-icon">üî®</div>
                    <div class="card-name">BREACHER</div>
                    <div class="card-desc">Heavy Armor. Axe + Shotgun. Breaks walls.</div>
                </div>
                <div class="card" onclick="Game.setClass('medic', this)">
                    <div class="card-icon">üíâ</div>
                    <div class="card-name">MEDIC</div>
                    <div class="card-desc">Fast Speed. Medkit + Hose. Revives squad.</div>
                </div>
                <div class="card" onclick="Game.setClass('tech', this)">
                    <div class="card-icon">üìü</div>
                    <div class="card-name">TECH</div>
                    <div class="card-desc">Thermal Vision. Scanner + Extinguisher. Sees through smoke.</div>
                </div>
            </div>

            <div style="margin-bottom: 10px; color: #aaa; font-size: 12px;">MISSION BRIEFING:</div>
            <div style="background:#111; padding:10px; font-size:11px; color:#888; margin-bottom:20px; border:1px solid #333;">
                TARGET: WAREHOUSE SECTOR 7<br>
                INTEL: STRUCTURAL INSTABILITY DETECTED.<br>
                OBJECTIVE: LOCATE AND EXTRACT DATA SERVERS.
            </div>

            <button class="start-btn" onclick="Game.init()">INITIATE OPERATION</button>
        </div>
    </div>

    <script>
        /**
         * HAZARD OPS ENGINE v1.0
         * Optimized for JS13K / Low-end Devices
         */

        // --- MATH & HELPERS ---
        const PI2 = Math.PI * 2;
        const Dist = (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1);
        const Clamp = (v, min, max) => Math.max(min, Math.min(max, v));
        const Rnd = (min, max) => Math.random() * (max - min) + min;
        const RndInt = (min, max) => Math.floor(Rnd(min, max));

        // --- AUDIO ENGINE (Synthesizer) ---
        const AudioSys = {
            ctx: null,
            init() {
                window.AudioContext = window.AudioContext || window.webkitAudioContext;
                this.ctx = new AudioContext();
            },
            playTone(freq, type, duration, vol = 0.1) {
                if (!this.ctx) return;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
                gain.gain.setValueAtTime(vol, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                osc.connect(gain);
                gain.connect(this.ctx.destination);
                osc.start();
                osc.stop(this.ctx.currentTime + duration);
            },
            playNoise(duration) {
                if (!this.ctx) return;
                const bufferSize = this.ctx.sampleRate * duration;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
                
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                const gain = this.ctx.createGain();
                gain.gain.value = 0.1;
                gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
                noise.connect(gain);
                gain.connect(this.ctx.destination);
                noise.start();
            },
            sfx: {
                step: () => AudioSys.playNoise(0.05),
                shot: () => { AudioSys.playNoise(0.2); AudioSys.playTone(100, 'sawtooth', 0.1); },
                beep: () => AudioSys.playTone(800, 'sine', 0.1),
                alert: () => AudioSys.playTone(150, 'square', 0.3)
            }
        };

        // --- INPUT SYSTEM ---
        const Input = {
            x: 0, y: 0, active: false,
            action: false, fire: false
        };

        // Joystick Logic
        const joy = document.getElementById('joystick');
        const knob = document.getElementById('joy-knob');
        let jStartX, jStartY;

        joy.addEventListener('touchstart', e => {
            e.preventDefault();
            const t = e.touches[0];
            jStartX = t.clientX; jStartY = t.clientY;
            Input.active = true;
        }, {passive: false});

        joy.addEventListener('touchmove', e => {
            e.preventDefault();
            if (!Input.active) return;
            const t = e.touches[0];
            let dx = t.clientX - jStartX;
            let dy = t.clientY - jStartY;
            const dist = Math.min(35, Math.hypot(dx, dy));
            const ang = Math.atan2(dy, dx);
            
            Input.x = Math.cos(ang) * (dist/35);
            Input.y = Math.sin(ang) * (dist/35);
            
            knob.style.transform = `translate(calc(-50% + ${Math.cos(ang)*dist}px), calc(-50% + ${Math.sin(ang)*dist}px))`;
        }, {passive: false});

        const resetInput = () => {
            Input.active = false; Input.x = 0; Input.y = 0;
            knob.style.transform = `translate(-50%, -50%)`;
        };
        joy.addEventListener('touchend', resetInput);
        
        // Keyboard fallback for PC debugging
        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if(e.code === 'KeyW') Input.y = -1;
            if(e.code === 'KeyS') Input.y = 1;
            if(e.code === 'KeyA') Input.x = -1;
            if(e.code === 'KeyD') Input.x = 1;
            if(e.code === 'Space') Input.fire = true;
            Input.active = true;
        });
        window.addEventListener('keyup', e => {
            keys[e.code] = false;
            if(!keys['KeyW'] && !keys['KeyS']) Input.y = 0;
            if(!keys['KeyA'] && !keys['KeyD']) Input.x = 0;
            if(e.code === 'Space') Input.fire = false;
        });

        // --- GAME ENGINE ---
        const cvs = document.getElementById('gameCanvas');
        const ctx = cvs.getContext('2d', { alpha: false });

        const CFG = {
            tileSize: 40,
            mapW: 40, mapH: 40,
            viewDist: 300,
            colors: { wall: '#222', floor: '#111', fire: '#f50', smoke: '#333' }
        };

        // Grid Systems (TypedArrays for performance)
        const Grid = {
            map: new Uint8Array(CFG.mapW * CFG.mapH), // 0:Floor, 1:Wall, 2:DoorClsd, 3:DoorOpen, 4:Obj
            fire: new Uint8Array(CFG.mapW * CFG.mapH), // 0-255 Heat
            smoke: new Uint8Array(CFG.mapW * CFG.mapH), // 0-255 Density
            
            idx(x, y) { return (y | 0) * CFG.mapW + (x | 0); },
            isSolid(x, y) {
                if (x < 0 || x >= CFG.mapW || y < 0 || y >= CFG.mapH) return true;
                const t = this.map[this.idx(x, y)];
                return t === 1 || t === 2;
            },
            set(x, y, val) { this.map[this.idx(x,y)] = val; }
        };

        // --- RAYCASTING (LIGHTING) ---
        function castRays(ox, oy, angle) {
            const rays = [];
            const fov = Math.PI / 2;
            const rayCount = 50;
            const step = fov / rayCount;

            for (let i = -rayCount/2; i < rayCount/2; i++) {
                const rayAngle = angle + i * step;
                let dx = Math.cos(rayAngle);
                let dy = Math.sin(rayAngle);
                let dist = 0;
                let hit = false;

                // DDA-ish simplified
                let cx = ox;
                let cy = oy;

                while (!hit && dist < CFG.viewDist) {
                    cx += dx * 10;
                    cy += dy * 10;
                    dist += 10;

                    // Check wall collision
                    const gx = Math.floor(cx / CFG.tileSize);
                    const gy = Math.floor(cy / CFG.tileSize);
                    
                    if (Grid.isSolid(gx, gy)) {
                        hit = true;
                    }
                }
                rays.push({ x: cx, y: cy });
            }
            return rays;
        }

        // --- ENTITIES ---
        class Entity {
            constructor(x, y, type) {
                this.x = x; this.y = y;
                this.type = type;
                this.angle = 0;
                this.radius = 10;
                this.active = true;
            }
        }

        class Player extends Entity {
            constructor(x, y, cls) {
                super(x, y, 'player');
                this.class = cls;
                this.hp = 100;
                this.o2 = 100;
                this.tool = 0; // 0: Main, 1: Extinguisher/Hose
                this.flashOn = true;
            }
            update() {
                // Move
                if (Input.x !== 0 || Input.y !== 0) {
                    let nx = this.x + Input.x * 3;
                    let ny = this.y + Input.y * 3;
                    
                    // Simple Circle Collision
                    let gx = Math.floor(nx / CFG.tileSize);
                    let gy = Math.floor(ny / CFG.tileSize);
                    
                    if (!Grid.isSolid(gx, Math.floor(this.y / CFG.tileSize))) this.x = nx;
                    if (!Grid.isSolid(Math.floor(this.x / CFG.tileSize), gy)) this.y = ny;

                    this.angle = Math.atan2(Input.y, Input.x);
                    
                    if (Math.random() < 0.1) AudioSys.sfx.step();
                }

                // Interaction
                if (Input.fire) {
                    if (this.tool === 0 && this.class === 'breacher') {
                        // Axe Logic
                        let ax = this.x + Math.cos(this.angle)*30;
                        let ay = this.y + Math.sin(this.angle)*30;
                        let idx = Grid.idx(Math.floor(ax/40), Math.floor(ay/40));
                        if (Grid.map[idx] === 2 || Grid.map[idx] === 1) { // Break door/wall
                             Grid.map[idx] = 0;
                             ParticleSys.spawn(ax, ay, 'debris', 10);
                             AudioSys.sfx.shot(); // Bang sound
                        }
                    } else {
                        // Extinguisher / Hose
                        let nx = this.x + Math.cos(this.angle) * 20;
                        let ny = this.y + Math.sin(this.angle) * 20;
                        ParticleSys.spawn(nx, ny, 'water', 1, Math.cos(this.angle)*8, Math.sin(this.angle)*8);
                        AudioSys.playNoise(0.05);
                    }
                }

                // Environmental Damage
                let idx = Grid.idx(Math.floor(this.x/40), Math.floor(this.y/40));
                if (Grid.fire[idx] > 50) {
                    this.hp -= 0.5;
                    UI.notify("HIGH TEMP WARNING", "red");
                }
                if (Grid.smoke[idx] > 100) this.o2 -= 0.1;
                
                // UI Sync
                document.getElementById('ui-o2').style.width = this.o2 + '%';
                document.getElementById('ui-temp').innerText = Math.floor(20 + Grid.fire[idx]) + '¬∞C';
                if(Grid.fire[idx]>100) document.getElementById('temp-mod').classList.add('danger');
                else document.getElementById('temp-mod').classList.remove('danger');
            }
        }

        class SquadBot extends Entity {
            constructor(x, y) {
                super(x, y, 'bot');
                this.state = 'follow'; // follow, hold
            }
            update(target) {
                let dist = Dist(this.x, this.y, target.x, target.y);
                if (this.state === 'follow' && dist > 50) {
                    let ang = Math.atan2(target.y - this.y, target.x - this.x);
                    this.x += Math.cos(ang) * 2.5;
                    this.y += Math.sin(ang) * 2.5;
                    this.angle = ang;
                }
                
                // Auto Extinguish
                let gx = Math.floor(this.x/40), gy = Math.floor(this.y/40);
                if (Grid.fire[Grid.idx(gx, gy)] > 10) {
                    ParticleSys.spawn(this.x, this.y, 'water', 1, Math.cos(this.angle)*5, Math.sin(this.angle)*5);
                }
            }
        }

        // --- PARTICLE SYSTEM (Object Pooling) ---
        const ParticleSys = {
            pool: [],
            init() { for(let i=0; i<500; i++) this.pool.push({x:0,y:0,vx:0,vy:0,life:0,type:''}); },
            spawn(x, y, type, count=1, vx=0, vy=0) {
                for(let i=0; i<count; i++) {
                    const p = this.pool.find(p => p.life <= 0);
                    if (!p) return;
                    p.x = x; p.y = y;
                    p.vx = (vx || (Math.random()-0.5)*2) + (Math.random()-0.5);
                    p.vy = (vy || (Math.random()-0.5)*2) + (Math.random()-0.5);
                    p.type = type;
                    p.life = 1.0;
                }
            },
            updateAndDraw(ctx, camX, camY) {
                for (const p of this.pool) {
                    if (p.life <= 0) continue;
                    p.x += p.vx; p.y += p.vy;
                    p.life -= 0.02;
                    
                    // Interaction
                    if (p.type === 'water') {
                        let idx = Grid.idx(Math.floor(p.x/40), Math.floor(p.y/40));
                        if (Grid.fire[idx] > 0) {
                            Grid.fire[idx] -= 5;
                            p.life = 0;
                            ParticleSys.spawn(p.x, p.y, 'steam', 1);
                        }
                    }

                    if (p.x < camX || p.x > camX + W || p.y < camY || p.y > camY + H) continue;

                    ctx.globalAlpha = p.life;
                    if (p.type === 'water') ctx.fillStyle = '#0cf';
                    else if (p.type === 'fire') ctx.fillStyle = '#f50';
                    else if (p.type === 'steam') ctx.fillStyle = '#ccc';
                    else ctx.fillStyle = '#fff';
                    
                    ctx.beginPath(); ctx.arc(p.x-camX, p.y-camY, p.type==='steam'?4:2, 0, Math.PI*2); ctx.fill();
                }
                ctx.globalAlpha = 1;
            }
        };

        // --- PROCEDURAL GENERATION ---
        function GenerateMap() {
            // Initialize
            Grid.map.fill(1); // All walls
            Grid.fire.fill(0);
            Grid.smoke.fill(0);

            // Drunkard's Walk for Rooms
            let minerX = 20, minerY = 20;
            let floorCount = 0;
            
            while(floorCount < 600) {
                Grid.set(minerX, minerY, 0); // Floor
                
                let dir = Math.floor(Math.random() * 4);
                if (dir === 0) minerX++;
                if (dir === 1) minerX--;
                if (dir === 2) minerY++;
                if (dir === 3) minerY--;
                
                minerX = Clamp(minerX, 2, CFG.mapW-3);
                minerY = Clamp(minerY, 2, CFG.mapH-3);
                
                if (Math.random() < 0.05) {
                    // Create Room
                    for(let rx=0; rx<5; rx++) for(let ry=0; ry<5; ry++) Grid.set(minerX+rx, minerY+ry, 0);
                }
                floorCount++;
            }

            // Add Doors & Objectives
            for (let i=0; i<CFG.mapW*CFG.mapH; i++) {
                if (Grid.map[i] === 0 && Math.random() < 0.02) {
                    // Check neighbors
                    // Simplified logic for demo
                    if (Math.random() < 0.5) Grid.map[i] = 2; // Door
                }
                if (Grid.map[i] === 0 && Math.random() < 0.005) Grid.fire[i] = 200; // Start Fire
            }
        }

        // --- MAIN GAME OBJECT ---
        const Game = {
            active: false,
            player: null,
            squad: [],
            classType: 'breacher',
            
            setClass(cls, el) {
                this.classType = cls;
                document.querySelectorAll('.card').forEach(c => c.classList.remove('selected'));
                el.classList.add('selected');
            },

            init() {
                AudioSys.init();
                ParticleSys.init();
                document.getElementById('menu').classList.add('hidden');
                
                GenerateMap();
                
                // Spawn Player in valid spot
                let startX = 20 * 40, startY = 20 * 40;
                this.player = new Player(startX, startY, this.classType);
                this.squad.push(new SquadBot(startX - 40, startY));
                
                this.active = true;
                UI.notify("MISSION START");
                requestAnimationFrame(Loop);
            },

            toggleCommand() {
                let bot = this.squad[0];
                if (bot.state === 'follow') {
                    bot.state = 'hold';
                    UI.notify("SQUAD: HOLDING POSITION");
                    document.getElementById('ui-squad').innerText = "HOLD";
                } else {
                    bot.state = 'follow';
                    UI.notify("SQUAD: FORMING UP");
                    document.getElementById('ui-squad').innerText = "FOLLOW";
                }
            },

            switchTool() {
                this.player.tool = this.player.tool === 0 ? 1 : 0;
                UI.notify("WEAPON SWAPPED");
            }
        };

        const UI = {
            notify(msg, col='#fff') {
                const div = document.createElement('div');
                div.className = 'msg';
                div.innerText = msg;
                div.style.color = col;
                document.getElementById('notifications').appendChild(div);
                setTimeout(() => div.remove(), 1500);
            }
        };

        // --- MAIN LOOP ---
        function Loop() {
            if (!Game.active) return;

            // Update Physics
            Game.player.update();
            Game.squad.forEach(b => b.update(Game.player));

            // Fire Simulation (Cellular Automata)
            // Optimized: Update random chunks or iterate
            for (let i=0; i<100; i++) {
                let idx = Math.floor(Math.random() * (CFG.mapW * CFG.mapH));
                if (Grid.fire[idx] > 0) {
                    // Spread
                    let n = idx + (Math.random() > 0.5 ? 1 : -1);
                    if (Grid.map[n] !== 1) {
                        Grid.fire[n] = Math.min(255, Grid.fire[n] + 2);
                        Grid.smoke[n] = Math.min(255, Grid.smoke[n] + 1);
                    }
                    // Particles
                    if (Math.random() < 0.05) {
                        let y = Math.floor(idx/CFG.mapW) * 40;
                        let x = (idx%CFG.mapW) * 40;
                        ParticleSys.spawn(x+20, y+20, 'fire', 1);
                    }
                }
            }

            // Render
            // Camera Calc
            let cx = Game.player.x - W/2;
            let cy = Game.player.y - H/2;
            
            // Clear
            ctx.fillStyle = '#050505';
            ctx.fillRect(0, 0, W, H);

            // Draw Map
            const startCol = Math.floor(cx / CFG.tileSize);
            const endCol = startCol + (W / CFG.tileSize) + 1;
            const startRow = Math.floor(cy / CFG.tileSize);
            const endRow = startRow + (H / CFG.tileSize) + 1;

            for (let c = startCol; c <= endCol; c++) {
                for (let r = startRow; r <= endRow; r++) {
                    if (c < 0 || c >= CFG.mapW || r < 0 || r >= CFG.mapH) continue;
                    
                    let tile = Grid.map[Grid.idx(c, r)];
                    let x = Math.round(c * CFG.tileSize - cx);
                    let y = Math.round(r * CFG.tileSize - cy);

                    if (tile === 1) { // Wall
                        ctx.fillStyle = '#1a1a1a';
                        ctx.fillRect(x, y, CFG.tileSize, CFG.tileSize);
                        ctx.strokeStyle = '#333';
                        ctx.strokeRect(x, y, CFG.tileSize, CFG.tileSize);
                        // 3D Top effect
                        ctx.fillStyle = '#000';
                        ctx.fillRect(x, y-10, CFG.tileSize, 10);
                    } else if (tile === 2) { // Door Closed
                        ctx.fillStyle = '#422';
                        ctx.fillRect(x+5, y+5, 30, 30);
                    } else { // Floor
                        ctx.fillStyle = '#0c0c0c';
                        ctx.fillRect(x, y, CFG.tileSize, CFG.tileSize);
                        
                        // Render Fire Overlay
                        let fireVal = Grid.fire[Grid.idx(c, r)];
                        if (fireVal > 0) {
                            ctx.fillStyle = `rgba(255, 50, 0, ${fireVal/300})`;
                            ctx.fillRect(x, y, CFG.tileSize, CFG.tileSize);
                        }
                    }
                }
            }

            // Particles
            ParticleSys.updateAndDraw(ctx, cx, cy);

            // Dynamic Lighting (Shadows)
            const rays = castRays(Game.player.x, Game.player.y, Game.player.angle);
            
            // Draw Flashlight Cone
            ctx.save();
            ctx.translate(-cx, -cy);
            ctx.beginPath();
            ctx.moveTo(Game.player.x, Game.player.y);
            for (const p of rays) ctx.lineTo(p.x, p.y);
            ctx.closePath();
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.fill();
            ctx.restore();

            // Draw Player
            const px = Game.player.x - cx;
            const py = Game.player.y - cy;
            
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(Game.player.angle);
            
            // Body
            ctx.fillStyle = '#fff';
            ctx.beginPath(); ctx.arc(0, 0, 10, 0, PI2); ctx.fill();
            // Helmet
            ctx.fillStyle = '#e63946';
            ctx.fillRect(-5, -5, 10, 10);
            // Tool
            ctx.fillStyle = '#888';
            ctx.fillRect(5, 2, 15, 4);
            
            ctx.restore();

            // Draw Squad
            for(let bot of Game.squad) {
                ctx.save();
                ctx.translate(bot.x - cx, bot.y - cy);
                ctx.rotate(bot.angle);
                ctx.fillStyle = '#457b9d';
                ctx.beginPath(); ctx.arc(0, 0, 10, 0, PI2); ctx.fill();
                ctx.restore();
            }

            requestAnimationFrame(Loop);
        }

        // --- STARTUP ---
        if(window.Telegram && window.Telegram.WebApp) window.Telegram.WebApp.ready();

    </script>
</body>
</html>
